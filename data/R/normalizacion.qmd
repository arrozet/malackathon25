---
title: "Normalización de Salud Mental"
format:
  pdf:
    toc: true
    number-sections: true
    fig-format: jpeg
    dpi: 120
editor: visual
---

## Objetivo

Este cuaderno documenta la normalización del dataset `SaludMental_limpio_anon.xlsx` en tablas de dimensiones, hechos y relaciones. Se justifica cada decisión para garantizar trazabilidad con el modelo lógico requerido por Oracle Autonomous Database 23ai.

## Librerías

Utilizamos paquetes del tidyverse para transformación y `writexl` para la exportación final, manteniendo herramientas ya aprobadas en el proyecto.

```{r}
library(tidyverse)
library(readxl)
library(writexl)
library(lubridate)
library(purrr)

#' Envuelve un vector de caracteres en comillas simples escapando su contenido.
#'
#' @param x vector con valores que se desean serializar como texto.
#' @return vector `character` con las entradas rodeadas de comillas simples.
sql_quote <- function(x) {
  x <- as.character(x)
  ifelse(
    is.na(x),
    NA_character_,
    paste0("'", stringr::str_replace_all(x, "'", "''"), "'")
  )
}

#' Convierte valores booleanos o equivalentes a enteros 0/1 para SQL.
#'
#' @param x vector con valores lógicos, numéricos o textos equivalentes a booleanos.
#' @return vector `integer` con valores 0, 1 o `NA` si no se puede determinar.
to_binary <- function(x) {
  if (is.logical(x)) {
    return(as.integer(x))
  }
  if (is.numeric(x)) {
    return(ifelse(is.na(x), NA_integer_, ifelse(x == 0, 0L, 1L)))
  }
  x_chr <- stringr::str_to_upper(stringr::str_trim(as.character(x)))
  x_chr[x_chr %in% c("", "NA")] <- NA_character_
  dplyr::case_when(
    x_chr %in% c("TRUE", "T", "SI", "S", "1") ~ 1L,
    x_chr %in% c("FALSE", "F", "NO", "N", "0") ~ 0L,
    TRUE ~ NA_integer_
  )
}
```

## Carga de datos

Leemos el Excel anonimizado respetando los nombres de columnas originales. Se usa `read_excel` para mantener los tipos reportados por el archivo.

```{r}
datos_brutos <- read_excel("./SaludMental_limpio_anon.xlsx")

glimpse(datos_brutos)
```

## Preparación de tablas de dimensiones

En esta sección derivamos catálogos independientes que servirán como claves foráneas en la tabla de hechos. Mantenemos los identificadores alineados con los valores originales para evitar mapeos artificiales.

### Comunidades Autónomas

El identificador primario `ID_Comunidad_Autonoma` se alinea con el texto de la comunidad, tal como exige la documentación (“Corresponde a Comunidad Autónoma”). Esto simplifica la validación con los datos origen.

```{r}
comunidades_autonomas_tbl <- datos_brutos %>%
  distinct(`Comunidad Autónoma`) %>%
  filter(!is.na(`Comunidad Autónoma`), `Comunidad Autónoma` != "") %>%
  transmute(
    ID_Comunidad_Autonoma = sql_quote(`Comunidad Autónoma`),
    Nombre_Comunidad = sql_quote(`Comunidad Autónoma`)
  ) %>%
  arrange(Nombre_Comunidad)

comunidades_autonomas_tbl %>% slice_head(n = 10)
```

### Países

Se consolidan los países de nacimiento y residencia en un único catálogo. El campo `ID_Pais` reutiliza el nombre oficial para mantener la trazabilidad con el Excel original.

```{r}
paises_tbl <- datos_brutos %>%
  select(`País Nacimiento`, `País Residencia`) %>%
  pivot_longer(everything(), names_to = "Origen", values_to = "ID_Pais") %>%
  filter(!is.na(ID_Pais), ID_Pais != "") %>%
  mutate(ID_Pais = str_remove(as.character(ID_Pais), "\\.0$")) %>%
  distinct(ID_Pais) %>%
  mutate(ID_Pais = sql_quote(ID_Pais)) %>%
  arrange(ID_Pais)

paises_tbl %>% slice_head(n = 10)
```

### Centros

Los centros ya cuentan con un código recodificado; lo utilizamos directamente como clave primaria para evitar duplicados.

```{r}
centros_tbl <- datos_brutos %>%
  distinct(`Centro Recodificado`) %>%
  filter(!is.na(`Centro Recodificado`), `Centro Recodificado` != "") %>%
  transmute(ID_Centro = suppressWarnings(as.numeric(`Centro Recodificado`))) %>%
  filter(!is.na(ID_Centro)) %>%
  arrange(ID_Centro)

centros_tbl %>% slice_head(n = 10)
```

### GRD_APR

El catálogo `GRD_APR` preserva la relación uno a muchos entre el código APR y sus atributos clínicos. Se usa `distinct` para eliminar redundancias.

```{r}
grd_apr_tbl <- datos_brutos %>%
  select(`GRD APR`, `CDM APR`, `Nivel Severidad APR`, `Riesgo Mortalidad APR`, `Tipo GRD APR`) %>%
  filter(!is.na(`GRD APR`), `GRD APR` != "") %>%
  distinct() %>%
  transmute(
    ID_GRD_APR = suppressWarnings(as.numeric(`GRD APR`)),
    CDM_APR = sql_quote(`CDM APR`),
    Nivel_Severidad_APR = sql_quote(`Nivel Severidad APR`),
    Riesgo_Mortalidad_APR = sql_quote(`Riesgo Mortalidad APR`),
    Tipo_GRD_APR = sql_quote(`Tipo GRD APR`)
  ) %>%
  filter(!is.na(ID_GRD_APR)) %>%
  arrange(ID_GRD_APR)

grd_apr_tbl %>% slice_head(n = 10)
```

### Diagnósticos

Integramos los diagnósticos principales y secundarios en un catálogo único. La categoría se obtiene cuando el diagnóstico aparece como principal; en los restantes casos se conserva como `NA`, garantizando que no se inventa información nueva.

```{r}
diagnostico_columnas <- names(datos_brutos) %>%
  str_subset("^Diagnóstico (Principal|[0-9]+)$")

diagnosticos_long <- datos_brutos %>%
  mutate(ID_Ingreso = row_number()) %>%
  select(ID_Ingreso, `Categoría`, all_of(diagnostico_columnas)) %>%
  pivot_longer(
    cols = all_of(diagnostico_columnas),
    names_to = "Columna_Diagnostico",
    values_to = "ID_Diagnostico"
  ) %>%
  filter(!is.na(ID_Diagnostico), ID_Diagnostico != "") %>%
  mutate(
    Orden_Diagnostico = if_else(
      Columna_Diagnostico == "Diagnóstico Principal",
      1L,
      as.integer(str_extract(Columna_Diagnostico, "\\d+"))
    )
  )

diagnosticos_tbl <- diagnosticos_long %>%
  group_by(ID_Diagnostico) %>%
  summarise(
    Categoria = {
      categorias_validas <- `Categoría`[Orden_Diagnostico == 1L]
      categorias_validas <- categorias_validas[!is.na(categorias_validas) & categorias_validas != ""]
      if (length(categorias_validas) == 0) NA_character_ else categorias_validas[1]
    },
    .groups = "drop"
  ) %>%
  mutate(ID_Diagnostico = sql_quote(ID_Diagnostico)) %>%
  arrange(ID_Diagnostico)

diagnosticos_tbl %>% slice_head(n = 10)
```

### Procedimientos

Los procedimientos se desnormalizan y se eliminan duplicados. Se mantiene la codificación original en `ID_Procedimiento` según el requerimiento.

```{r}
procedimiento_columnas <- names(datos_brutos) %>%
  str_subset("^Procedimiento [0-9]+$")

procedimientos_tbl <- datos_brutos %>%
  select(all_of(procedimiento_columnas)) %>%
  pivot_longer(cols = everything(), names_to = "Fuente", values_to = "ID_Procedimiento") %>%
  filter(!is.na(ID_Procedimiento), ID_Procedimiento != "") %>%
  distinct(ID_Procedimiento) %>%
  mutate(ID_Procedimiento = sql_quote(ID_Procedimiento)) %>%
  arrange(ID_Procedimiento)

procedimientos_tbl %>% slice_head(n = 10)
```

## Dimensión Pacientes

Se conserva una fila única por paciente (`UUID_Paciente`). Las claves foráneas referencian directamente a las tablas de catálogo ya construidas.

```{r}
pacientes_tbl <- datos_brutos %>%
  arrange(`UUID_Paciente`, `Fecha de Ingreso`) %>%
  distinct(`UUID_Paciente`, .keep_all = TRUE) %>%
  transmute(
    UUID_Paciente = sql_quote(`UUID_Paciente`),
    CIP_SNS_Recodificado = sql_quote(`CIP SNS Recodificado`),
    Fecha_de_nacimiento = sql_quote(format(as_date(`Fecha de nacimiento`), "%Y-%m-%d")),
    Sexo = sql_quote(`Sexo`),
    Grupo_Etario = sql_quote(`Grupo_Etario`),
    ID_Comunidad_Autonoma = sql_quote(`Comunidad Autónoma`),
    ID_Pais_Nacimiento = sql_quote(str_remove(as.character(`País Nacimiento`), "\\.0$")),
    ID_Pais_Residencia = sql_quote(str_remove(as.character(`País Residencia`), "\\.0$"))
  )

pacientes_tbl %>% slice_head(n = 10)
```

## Tabla de Hechos Ingresos

Cada fila representa un episodio hospitalario. Se genera `ID_Ingreso` secuencial para facilitar la carga en Oracle y se mantiene el resto de métricas conforme al diccionario.

```{r}
ingresos_tbl <- datos_brutos %>%
  mutate(
    ID_Ingreso = row_number(),
    ID_Centro = suppressWarnings(as.numeric(`Centro Recodificado`)),
    ID_GRD_APR = suppressWarnings(as.numeric(`GRD APR`)),
    Numero_de_registro_anual = round(suppressWarnings(as.numeric(`Número de registro anual`)), 2),
    Fecha_de_Inicio_contacto = case_when(
      !is.na(`Fecha Inicio Contacto Fecha`) & !is.na(`Fecha Inicio Contacto Hora`) & `Fecha Inicio Contacto Hora` != "" ~
        suppressWarnings(ymd_hm(paste(`Fecha Inicio Contacto Fecha`, `Fecha Inicio Contacto Hora`), tz = "UTC")),
      !is.na(`Fecha Inicio Contacto Fecha`) ~ ymd(`Fecha Inicio Contacto Fecha`),
      TRUE ~ as_datetime(NA)
    )
  ) %>%
  transmute(
    ID_Ingreso,
    UUID_Paciente = `UUID_Paciente`,
    ID_Centro,
    ID_GRD_APR,
    Numero_de_registro_anual,
    Fecha_de_Ingreso = if_else(is.na(`Fecha de Ingreso`), NA_character_, format(as_date(`Fecha de Ingreso`), "%Y-%m-%d")),
    Fecha_de_Fin_Contacto = if_else(is.na(`Fecha de Fin Contacto`), NA_character_, format(as_date(`Fecha de Fin Contacto`), "%Y-%m-%d")),
    Fecha_de_Inicio_contacto = if_else(is.na(Fecha_de_Inicio_contacto), NA_character_, format(Fecha_de_Inicio_contacto, "%Y-%m-%d %H:%M:%S")),
    Circunstancia_de_Contacto = suppressWarnings(as.numeric(`Circunstancia de Contacto`)),
    Tipo_Alta = suppressWarnings(as.numeric(`Tipo Alta`)),
    Servicio = sql_quote(`Servicio`),
    Regimen_Financiacion = round(suppressWarnings(as.numeric(`Régimen Financiación`)), 2),
    Procedencia = round(suppressWarnings(as.numeric(`Procedencia`)), 2),
    Continuidad_Asistencial = round(suppressWarnings(as.numeric(`Continuidad Asistencial`)), 2),
    Estancia_Dias = `Estancia Días`,
    Estancia_Dias_Acotada = `Estancia_Dias_Acotada`,
    Duracion_Episodio_Calculada = `Duracion_Episodio_Calculada`,
    Edad = `Edad`,
    Edad_en_Ingreso = `Edad en Ingreso`,
    Coste_APR = round(suppressWarnings(as.numeric(`Coste APR`)), 2),
    Peso_Español_APR = round(suppressWarnings(as.numeric(`Peso Español APR`)), 4),
    Ingreso_en_UCI = to_binary(`Ingreso en UCI`),
    Diagnosticos_totales = `Diagnosticos_totales`,
    Procedimientos_totales = `Procedimientos_totales`,
    Tiene_procedimiento = to_binary(`Tiene_procedimiento`),
    Diagnostico_F = to_binary(`Diagnostico_F`),
    Tiene_Comorbilidad = to_binary(`Tiene_Comorbilidad`)
  )

ingresos_tbl %>% slice_head(n = 10)
```

## Tablas de relación

Creamos tablas bridge para resolver las relaciones de muchos a muchos entre ingresos, diagnósticos y procedimientos.

### Ingreso_Diagnosticos

Se asigna un identificador incremental. El orden deriva de la posición original (principal = 1) y se conserva el indicador `POA` correspondiente.

```{r}
mapa_diagnosticos <- tibble(
  Columna_Diagnostico = c("Diagnóstico Principal", paste("Diagnóstico", 2:9)),
  Columna_POA = c("POA Diagnóstico Principal", paste("POA Diagnóstico", 2:9)),
  Orden_Diagnostico = c(1L, 2:9)
)

ingreso_diagnosticos_tbl <- purrr::pmap_dfr(
  list(
    mapa_diagnosticos$Columna_Diagnostico,
    mapa_diagnosticos$Columna_POA,
    mapa_diagnosticos$Orden_Diagnostico
  ),
  function(col_diag, col_poa, orden) {
    tibble(
      ID_Ingreso = seq_len(nrow(datos_brutos)),
      ID_Diagnostico = datos_brutos[[col_diag]],
      POA = if (col_poa %in% names(datos_brutos)) datos_brutos[[col_poa]] else NA_character_,
      Orden_Diagnostico = orden
    )
  }
) %>%
  filter(!is.na(ID_Diagnostico), ID_Diagnostico != "") %>%
  arrange(ID_Ingreso, Orden_Diagnostico) %>%
  mutate(ID_Ingreso_Diagnostico = row_number()) %>%
  select(ID_Ingreso_Diagnostico, ID_Ingreso, ID_Diagnostico, Orden_Diagnostico, POA)

ingreso_diagnosticos_tbl %>% slice_head(n = 10)
```

### Ingreso_Procedimientos

El orden mantiene la jerarquía del registro (`Procedimiento 1`, `2`, `3`). Se eliminan combinaciones vacías para evitar claves huérfanas.

```{r}
mapa_procedimientos <- tibble(
  Columna_Procedimiento = paste("Procedimiento", 1:3),
  Orden_Procedimiento = 1:3
)

ingreso_procedimientos_tbl <- purrr::pmap_dfr(
  list(
    mapa_procedimientos$Columna_Procedimiento,
    mapa_procedimientos$Orden_Procedimiento
  ),
  function(col_proc, orden) {
    valores_proc <- if (col_proc %in% names(datos_brutos)) datos_brutos[[col_proc]] else rep(NA_character_, nrow(datos_brutos))
    tibble(
      ID_Ingreso = seq_len(nrow(datos_brutos)),
      ID_Procedimiento = valores_proc,
      Orden_Procedimiento = orden
    )
  }
) %>%
  filter(!is.na(ID_Procedimiento), ID_Procedimiento != "") %>%
  arrange(ID_Ingreso, Orden_Procedimiento) %>%
  mutate(ID_Ingreso_Procedimiento = row_number()) %>%
  select(ID_Ingreso_Procedimiento, ID_Ingreso, ID_Procedimiento, Orden_Procedimiento)

ingreso_procedimientos_tbl %>% slice_head(n = 10)
```

## Exportación de resultados

Se escriben todas las tablas normalizadas a un único archivo Excel para facilitar su ingesta posterior. El archivo se almacena junto al cuaderno para mantener consistencia.

```{r}
salida_path <- "normalizacion_saludMental.xlsx"

write_xlsx(
  list(
    Comunidades_Autonomas = comunidades_autonomas_tbl,
    Paises = paises_tbl,
    Centros = centros_tbl,
    GRD_APR = grd_apr_tbl,
    Diagnosticos = diagnosticos_tbl,
    Procedimientos = procedimientos_tbl,
    Pacientes = pacientes_tbl,
    Ingresos = ingresos_tbl,
    Ingreso_Diagnosticos = ingreso_diagnosticos_tbl,
    Ingreso_Procedimientos = ingreso_procedimientos_tbl
  ),
  path = salida_path
)

salida_path
```

## Validaciones finales

Confirmamos integridad referencial básica y la coherencia de los contadores de diagnósticos y procedimientos respecto de las tablas de puente.

```{r}
validacion_diagnosticos <- ingreso_diagnosticos_tbl %>%
  count(ID_Ingreso, name = "n_diagnosticos") %>%
  right_join(ingresos_tbl %>% select(ID_Ingreso, Diagnosticos_totales), by = "ID_Ingreso") %>%
  mutate(n_diagnosticos = replace_na(n_diagnosticos, 0L)) %>%
  summarise(coincide = all(n_diagnosticos == Diagnosticos_totales))

validacion_procedimientos <- ingreso_procedimientos_tbl %>%
  count(ID_Ingreso, name = "n_procedimientos") %>%
  right_join(ingresos_tbl %>% select(ID_Ingreso, Procedimientos_totales), by = "ID_Ingreso") %>%
  mutate(n_procedimientos = replace_na(n_procedimientos, 0L)) %>%
  summarise(coincide = all(n_procedimientos == Procedimientos_totales))

fk_comunidades <- setdiff(pacientes_tbl$ID_Comunidad_Autonoma, comunidades_autonomas_tbl$ID_Comunidad_Autonoma)
fk_pais_nac <- setdiff(pacientes_tbl$ID_Pais_Nacimiento, paises_tbl$ID_Pais)
fk_pais_res <- setdiff(pacientes_tbl$ID_Pais_Residencia, paises_tbl$ID_Pais)
fk_centros <- setdiff(ingresos_tbl$ID_Centro, centros_tbl$ID_Centro)
fk_grd <- setdiff(ingresos_tbl$ID_GRD_APR, grd_apr_tbl$ID_GRD_APR)

list(
  diagnosticos_consistentes = validacion_diagnosticos$coincide,
  procedimientos_consistentes = validacion_procedimientos$coincide,
  fk_comunidades_pendientes = fk_comunidades,
  fk_pais_nacimiento_pendientes = fk_pais_nac,
  fk_pais_residencia_pendientes = fk_pais_res,
  fk_centros_pendientes = fk_centros,
  fk_grd_pendientes = fk_grd
)
```
---
title: "Normalización de Salud Mental"
format:
  html:
    toc: true
    number-sections: true
    df-print: paged
editor: visual
---

## Introducción

Este cuaderno documenta la normalización del dataset anonimizado `SaludMental_limpio_anon.xlsx` en tablas de dimensiones, hechos y relaciones conforme al modelo relacional requerido para la base de datos Oracle Autonomous Database 23ai. Cada paso justifica las decisiones de limpieza, deduplicación y generación de claves, priorizando la trazabilidad clínica y el cumplimiento de gobernanza de datos sanitarios.

## Librerías

```{r}
library(tidyverse)
library(readxl)
library(janitor)
library(lubridate)
library(stringr)

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
```

Las librerías seleccionadas cubren la lectura del Excel (`readxl`), la estandarización de nombres (`janitor`) y las transformaciones declarativas (`tidyverse`) necesarias para crear las tablas normalizadas de forma reproducible.

## Carga y preparación del dataset base

```{r}
datos_brutos <- read_excel(file.path("..", "SaludMental_limpio_anon.xlsx")) %>%
  clean_names()

datos <- datos_brutos %>%
  mutate(
    comunidad_autonoma = str_squish(str_to_upper(as.character(comunidad_autonoma))),
    pais_nacimiento = as.character(pais_nacimiento),
    pais_residencia = as.character(pais_residencia),
    centro_recodificado = str_squish(str_to_upper(as.character(centro_recodificado))),
    sexo = str_squish(str_to_upper(as.character(sexo))),
    grupo_etario = str_squish(str_to_upper(as.character(grupo_etario))),
    categoria = str_squish(as.character(categoria))
  )

glimpse(datos)
```

Primero limpiamos los nombres de columnas para trabajar con identificadores consistentes en `snake_case`. Posteriormente homogenizamos textos clave en mayúsculas y sin espacios redundantes, lo que garantiza joins deterministas al generar las dimensiones. El `glimpse` actúa como comprobación rápida de tipos y detecta posibles anomalías antes de construir las tablas.

## Tablas de dimensiones

### Comunidades Autónomas

```{r}
dim_comunidades_autonomas <- datos %>%
  distinct(comunidad_autonoma) %>%
  filter(!is.na(comunidad_autonoma), comunidad_autonoma != "") %>%
  mutate(
    ID_Comunidad_Autonoma = dense_rank(comunidad_autonoma),
    Nombre_Comunidad = sql_quote(comunidad_autonoma)
  ) %>%
  select(ID_Comunidad_Autonoma, Nombre_Comunidad) %>%
  arrange(ID_Comunidad_Autonoma)

dim_comunidades_autonomas
```

Asignamos claves numéricas secuenciales mediante `dense_rank`, preservando un catálogo compacto y estable. Esta tabla permite centralizar la descripción textual de cada comunidad autónoma evitando redundancias en la tabla de hechos.

### Países

```{r}
dim_paises <- datos %>%
  select(pais_nacimiento, pais_residencia) %>%
  pivot_longer(everything(), values_to = "ID_Pais", values_drop_na = TRUE) %>%
  mutate(ID_Pais = str_squish(as.character(ID_Pais))) %>%
  filter(ID_Pais != "") %>%
  distinct(ID_Pais) %>%
  mutate(ID_Pais = sql_quote(ID_Pais)) %>%
  arrange(ID_Pais)

dim_paises
```

Construimos un catálogo único de IDs de país presentes en el dataset, lo que permite mantener la trazabilidad sin asumir descripciones textuales externas.

### Centros

```{r}
dim_centros <- datos %>%
  distinct(centro_recodificado) %>%
  filter(!is.na(centro_recodificado), centro_recodificado != "") %>%
  transmute(
    ID_Centro = suppressWarnings(as.numeric(centro_recodificado))
  ) %>%
  filter(!is.na(ID_Centro)) %>%
  arrange(ID_Centro)

dim_centros
```

El identificador de centro se toma directamente del código recodificado proporcionado por la administración sanitaria, lo que preserva la trazabilidad oficial y evita generar IDs artificiales innecesarios.

### Diagnósticos

```{r}
diagnostico_cols <- datos %>%
  select(matches("^diagnostico_(principal|[0-9]+)$")) %>%
  names()

dim_diagnosticos <- datos %>%
  mutate(Categoria = str_squish(as.character(categoria))) %>%
  mutate(Categoria = if_else(Categoria == "", NA_character_, Categoria)) %>%
  mutate(Categoria = replace_na(Categoria, "Categoría pendiente de documentación")) %>%
  select(all_of(c(diagnostico_cols, "Categoria"))) %>%
  pivot_longer(
    cols = all_of(diagnostico_cols),
    values_to = "ID_Diagnostico",
    names_to = "Fuente",
    values_drop_na = TRUE
  ) %>%
  mutate(
    ID_Diagnostico = str_squish(str_to_upper(ID_Diagnostico))
  ) %>%
  filter(ID_Diagnostico != "") %>%
  distinct(ID_Diagnostico, .keep_all = TRUE) %>%
  select(ID_Diagnostico, Categoria) %>%
  arrange(ID_Diagnostico)

dim_diagnosticos
```

Aprovechamos la descripción entregada por el Excel (`Categoria`) para registrar la etiqueta oficial asociada a cada código. Al centralizarla en la dimensión evitamos divergencias semánticas en las capas de servicio y visualización.

### Procedimientos

```{r}
procedimiento_cols <- datos %>%
  select(matches("^procedimiento_[0-9]+$")) %>%
  names()

dim_procedimientos <- datos %>%
  select(all_of(procedimiento_cols)) %>%
  pivot_longer(everything(), values_to = "ID_Procedimiento", values_drop_na = TRUE) %>%
  mutate(ID_Procedimiento = str_squish(str_to_upper(ID_Procedimiento))) %>%
  filter(ID_Procedimiento != "") %>%
  distinct(ID_Procedimiento) %>%
  arrange(ID_Procedimiento)

dim_procedimientos
```

Los códigos de procedimiento se mantienen tal como figuran en el dataset, asegurando la compatibilidad con manuales quirúrgicos y permitiendo joins directos desde la tabla de relación `Ingreso_Procedimientos`.

### GRD APR

```{r}
dim_grd_apr <- datos %>%
  distinct(grd_apr, cdm_apr, nivel_severidad_apr, riesgo_mortalidad_apr, tipo_grd_apr) %>%
  filter(!is.na(grd_apr)) %>%
  transmute(
    ID_GRD_APR = suppressWarnings(as.numeric(grd_apr)),
    CDM_APR = sql_quote(cdm_apr),
    Nivel_Severidad_APR = sql_quote(nivel_severidad_apr),
    Riesgo_Mortalidad_APR = sql_quote(riesgo_mortalidad_apr),
    Tipo_GRD_APR = sql_quote(tipo_grd_apr)
  ) %>%
  filter(!is.na(ID_GRD_APR)) %>%
  arrange(ID_GRD_APR)

dim_grd_apr
```

Al conservar `GRD APR` como clave primaria garantizamos la coherencia con los agrupadores clínicos oficiales y documentamos junto a cada código sus atributos críticos (CDM, severidad, riesgo y tipo).

### Pacientes

```{r}
pacientes <- datos %>%
  left_join(dim_comunidades_autonomas, by = c("comunidad_autonoma" = "Nombre_Comunidad")) %>%
  transmute(
    UUID_Paciente = uuid_paciente,
    CIP_SNS_Recodificado = cip_sns_recodificado,
    Fecha_de_nacimiento = as_date(fecha_de_nacimiento),
    Sexo = sexo,
    Grupo_Etario = grupo_etario,
    ID_Comunidad_Autonoma,
    ID_Pais_Nacimiento = pais_nacimiento,
    ID_Pais_Residencia = pais_residencia
  ) %>%
  distinct(UUID_Paciente, .keep_all = TRUE)

pacientes
```

Normalizamos la dimensión `Pacientes` utilizando la UUID anonimizada como clave natural. Cada registro referencia a su comunidad y países mediante claves foráneas, eliminando redundancias y facilitando futuras ampliaciones del catálogo geográfico.

## Tabla de hechos `Ingresos`

```{r}
fact_ingresos <- datos %>%
  mutate(
    ID_Ingreso = row_number()
  ) %>%
  left_join(
    pacientes %>% select(UUID_Paciente, ID_Comunidad_Autonoma, ID_Pais_Nacimiento, ID_Pais_Residencia),
    by = c("uuid_paciente" = "UUID_Paciente")
  ) %>%
  transmute(
    ID_Ingreso,
    UUID_Paciente = uuid_paciente,
    ID_Centro = suppressWarnings(as.numeric(centro_recodificado)),
    ID_GRD_APR = suppressWarnings(as.numeric(grd_apr)),
    Numero_de_registro_anual = round(suppressWarnings(as.numeric(numero_de_registro_anual)), 2),
    Fecha_de_Ingreso = if_else(is.na(fecha_de_ingreso), NA_character_, format(as_date(fecha_de_ingreso), "%Y-%m-%d")),
    Fecha_de_Fin_Contacto = if_else(is.na(fecha_de_fin_contacto), NA_character_, format(as_date(fecha_de_fin_contacto), "%Y-%m-%d")),
    Fecha_de_Inicio_contacto = if_else(is.na(fecha_inicio_contacto_fecha), NA_character_, format(as_datetime(fecha_inicio_contacto_fecha), "%Y-%m-%d %H:%M:%S")),
    Circunstancia_de_Contacto = suppressWarnings(as.numeric(circunstancia_de_contacto)),
    Tipo_Alta = suppressWarnings(as.numeric(tipo_alta)),
    Servicio = sql_quote(servicio),
    Regimen_Financiacion = round(suppressWarnings(as.numeric(regimen_financiacion)), 2),
    Procedencia = round(suppressWarnings(as.numeric(procedencia)), 2),
    Continuidad_Asistencial = round(suppressWarnings(as.numeric(continuidad_asistencial)), 2),
    Estancia_Dias = estancia_dias,
    Estancia_Dias_Acotada = estancia_dias_acotada,
    Duracion_Episodio_Calculada = duracion_episodio_calculada,
    Edad = edad,
    Edad_en_Ingreso = edad_en_ingreso,
    Coste_APR = round(suppressWarnings(as.numeric(coste_apr)), 2),
    Peso_Español_APR = round(suppressWarnings(as.numeric(peso_espanol_apr)), 4),
    Ingreso_en_UCI = to_binary(ingreso_en_uci),
    Diagnosticos_totales = diagnosticos_totales,
    Procedimientos_totales = procedimientos_totales,
    Tiene_procedimiento = to_binary(tiene_procedimiento),
    Diagnostico_F = to_binary(diagnostico_f),
    Tiene_Comorbilidad = to_binary(tiene_comorbilidad)
  )

fact_ingresos
```

Generamos la clave sustituta `ID_Ingreso` para identificar cada episodio hospitalario. El resto de campos mantiene la granularidad original, enlazando con las dimensiones de pacientes, centros y GRD mediante claves foráneas, condición indispensable para análisis multidimensionales.

## Tablas de relación

### Ingreso_Diagnósticos

```{r}
ingreso_diagnosticos <- datos %>%
  mutate(ID_Ingreso = row_number()) %>%
  select(ID_Ingreso, all_of(diagnostico_cols)) %>%
  pivot_longer(
    cols = -ID_Ingreso,
    names_to = "Fuente",
    values_to = "ID_Diagnostico",
    values_drop_na = TRUE
  ) %>%
  mutate(
    ID_Diagnostico = str_squish(str_to_upper(ID_Diagnostico)),
    Orden_Diagnostico = case_when(
      Fuente == "diagnostico_principal" ~ 1L,
      TRUE ~ as.integer(str_extract(Fuente, "[0-9]+"))
    ),
    POA = NA_character_
  ) %>%
  select(ID_Ingreso, ID_Diagnostico, Orden_Diagnostico, POA) %>%
  arrange(ID_Ingreso, Orden_Diagnostico) %>%
  mutate(ID_Ingreso_Diagnostico = row_number()) %>%
  relocate(ID_Ingreso_Diagnostico)

ingreso_diagnosticos
```

Convertimos el esquema ancho en formato largo para eliminar columnas repetitivas (`Diagnóstico 1`, `Diagnóstico 2`, ...). La jerarquía clínica se conserva mediante `Orden_Diagnostico`, y se deja el campo `POA` preparado para integrar el indicador "Present on Admission" cuando la fuente oficial lo proporcione (actualmente ausente en el dataset anonimizado).

### Ingreso_Procedimientos

```{r}
ingreso_procedimientos <- datos %>%
  mutate(ID_Ingreso = row_number()) %>%
  select(ID_Ingreso, all_of(procedimiento_cols)) %>%
  pivot_longer(
    cols = -ID_Ingreso,
    names_to = "Fuente",
    values_to = "ID_Procedimiento",
    values_drop_na = TRUE
  ) %>%
  mutate(
    ID_Procedimiento = str_squish(str_to_upper(ID_Procedimiento)),
    Orden_Procedimiento = as.integer(str_extract(Fuente, "[0-9]+"))
  ) %>%
  select(ID_Ingreso, ID_Procedimiento, Orden_Procedimiento) %>%
  arrange(ID_Ingreso, Orden_Procedimiento) %>%
  mutate(ID_Ingreso_Procedimiento = row_number()) %>%
  relocate(ID_Ingreso_Procedimiento)

ingreso_procedimientos
```

De forma análoga, normalizamos los procedimientos. El orden asegura reproducir la secuencia clínica registrada y, al referenciar `ID_Procedimiento`, evitamos duplicidades en la tabla de hechos.

## Resumen de consistencia relacional

```{r}
list(
  dim_comunidades_autonomas = nrow(dim_comunidades_autonomas),
  dim_paises = nrow(dim_paises),
  dim_centros = nrow(dim_centros),
  dim_diagnosticos = nrow(dim_diagnosticos),
  dim_procedimientos = nrow(dim_procedimientos),
  dim_grd_apr = nrow(dim_grd_apr),
  pacientes = nrow(pacientes),
  fact_ingresos = nrow(fact_ingresos),
  ingreso_diagnosticos = nrow(ingreso_diagnosticos),
  ingreso_procedimientos = nrow(ingreso_procedimientos)
)
```

Este recuento global valida que la cardinalidad de cada tabla es coherente con la lógica del modelo estrella: las dimensiones poseen un número moderado de filas, mientras que la tabla de hechos y las relaciones mantienen el volumen esperado de episodios y asociaciones clínicas.

## Exportación para ingesta en Oracle

```{r}
dir.create("./salidas", showWarnings = FALSE, recursive = TRUE)

write_csv(dim_comunidades_autonomas, "./salidas/Comunidades_Autonomas.csv", na = "")
write_csv(dim_paises, "./salidas/Paises.csv", na = "")
write_csv(dim_centros, "./salidas/Centros.csv", na = "")
write_csv(dim_diagnosticos, "./salidas/Diagnosticos.csv", na = "")
write_csv(dim_procedimientos, "./salidas/Procedimientos.csv", na = "")
write_csv(dim_grd_apr, "./salidas/GRD_APR.csv", na = "")
write_csv(pacientes, "./salidas/Pacientes.csv", na = "")
write_csv(fact_ingresos, "./salidas/Ingresos.csv", na = "")
write_csv(ingreso_diagnosticos, "./salidas/Ingreso_Diagnosticos.csv", na = "")
write_csv(ingreso_procedimientos, "./salidas/Ingreso_Procedimientos.csv", na = "")
```

Persistimos cada tabla en formato CSV dentro de `salidas/`. Este formato es el esperado por `DBMS_CLOUD.COPY_DATA`, facilitando una ingesta directa en Oracle Autonomous Database sin transformaciones adicionales.

```{r}
write_xlsx(comunidades_autonomas_tbl, "./salidas/Comunidades_Autonomas.xlsx")
write_xlsx(paises_tbl, "./salidas/Paises.xlsx")
write_xlsx(centros_tbl, "./salidas/Centros.xlsx")
write_xlsx(grd_apr_tbl, "./salidas/GRD_APR.xlsx")
write_xlsx(diagnosticos_tbl, "./salidas/Diagnosticos.xlsx")
write_xlsx(procedimientos_tbl, "./salidas/Procedimientos.xlsx")
write_xlsx(pacientes_tbl, "./salidas/Pacientes.xlsx")
write_xlsx(ingresos_tbl, "./salidas/Ingresos.xlsx")
write_xlsx(ingreso_diagnosticos_tbl, "./salidas/Ingreso_Diagnosticos.xlsx")
write_xlsx(ingreso_procedimientos_tbl, "./salidas/Ingreso_Procedimientos.xlsx")
```

Además conservamos un Excel consolidado con todas las tablas normalizadas para auditoría y validaciones rápidas fuera del entorno Oracle.

